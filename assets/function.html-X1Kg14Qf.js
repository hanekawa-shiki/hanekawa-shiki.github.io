import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,b as r,o as a}from"./app-cIyTkk41.js";const n={};function c(p,t){return a(),o("div",null,t[0]||(t[0]=[r('<h1 id="函数" tabindex="-1"><a class="header-anchor" href="#函数"><span>函数</span></a></h1><h2 id="函数调用" tabindex="-1"><a class="header-anchor" href="#函数调用"><span>函数调用</span></a></h2><p>构造函数调用与常规函数和方法调用的区别在于<strong>参数处理</strong>、<strong>调用上下文</strong>和<strong>返回值</strong>。</p><p>构造函数调用会创建一个新的空对象，这个对象继承构造函数的<code>prototype</code>属性指定的对象。构造函数就是为初始化对象而设计的，这个新创建的对象会被用作函数的调用上下文，因此在构造函数中可以通过<code>this</code>关键字引用这个新对象。<strong>注意，即使构造函数调用看起来像方法调用，这个新对象也仍然会被用作调用上下文。换句话说，在表达式<code>new o.m()</code>中，<code>o</code>不会用作调用上下文。</strong></p><p>构造函数正常情况下不使用<code>return</code>关键字，而是初始化新对象并在到达函数体末尾时隐式返回这个对象。此时，这个新对象就是构造函数调用表达式的值。但是，如果构造函数显式使用了<code>return</code>语句返回某个对象，那该对象就会变成调用表达式的值。如果构造函数使用<code>return</code>但没有返回值，或者返回的是一个原始值，则这个返回值会被忽略，仍然以新创建的对象作为调用表达式的值。</p><h2 id="闭包" tabindex="-1"><a class="header-anchor" href="#闭包"><span>闭包</span></a></h2><p>前提：<code>JavaScript</code>函数是使用定义它们的作用域来执行的。</p><p>严格来讲，所有<code>JavaScript</code>函数都是闭包。但由于多数函数调用与函数定义都在同一作用域内，所以闭包的存在无关紧要。闭包真正值得关注的时候，是<strong>定义函数与调用函数的作用域不同的时候</strong>。最常见的情形就是一个函数返回了在它内部定义的嵌套函数。 很多强大的编程技术都是建立在这种嵌套函数闭包之上的，因此嵌套函数闭包在<code>JavaScript</code>程序中也变得比较常见。</p><p>简言之，闭包的本质:它们会捕获自身定义所在外部函数的局部变量(及参数)绑定。</p>',9)]))}const d=e(n,[["render",c]]),m=JSON.parse('{"path":"/ECMAScript/function.html","title":"函数","lang":"zh-CN","frontmatter":{"article":false,"description":"函数 函数调用 构造函数调用与常规函数和方法调用的区别在于参数处理、调用上下文和返回值。 构造函数调用会创建一个新的空对象，这个对象继承构造函数的prototype属性指定的对象。构造函数就是为初始化对象而设计的，这个新创建的对象会被用作函数的调用上下文，因此在构造函数中可以通过this关键字引用这个新对象。注意，即使构造函数调用看起来像方法调用，这个...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"函数\\",\\"description\\":\\"函数 函数调用 构造函数调用与常规函数和方法调用的区别在于参数处理、调用上下文和返回值。 构造函数调用会创建一个新的空对象，这个对象继承构造函数的prototype属性指定的对象。构造函数就是为初始化对象而设计的，这个新创建的对象会被用作函数的调用上下文，因此在构造函数中可以通过this关键字引用这个新对象。注意，即使构造函数调用看起来像方法调用，这个...\\"}"],["meta",{"property":"og:url","content":"https://hanekawa.top/ECMAScript/function.html"}],["meta",{"property":"og:site_name","content":"hanekawa-shiki"}],["meta",{"property":"og:title","content":"函数"}],["meta",{"property":"og:description","content":"函数 函数调用 构造函数调用与常规函数和方法调用的区别在于参数处理、调用上下文和返回值。 构造函数调用会创建一个新的空对象，这个对象继承构造函数的prototype属性指定的对象。构造函数就是为初始化对象而设计的，这个新创建的对象会被用作函数的调用上下文，因此在构造函数中可以通过this关键字引用这个新对象。注意，即使构造函数调用看起来像方法调用，这个..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-05T07:47:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-05T07:47:00.000Z"}]]},"git":{"createdTime":1720163434000,"updatedTime":1722844020000,"contributors":[{"name":"kamishima-kaede","username":"kamishima-kaede","email":"kamiacgxu@gmail.com","commits":5,"url":"https://github.com/kamishima-kaede"}]},"readingTime":{"minutes":1.82,"words":547},"filePathRelative":"ECMAScript/function.md","excerpt":"\\n<h2>函数调用</h2>\\n<p>构造函数调用与常规函数和方法调用的区别在于<strong>参数处理</strong>、<strong>调用上下文</strong>和<strong>返回值</strong>。</p>\\n<p>构造函数调用会创建一个新的空对象，这个对象继承构造函数的<code>prototype</code>属性指定的对象。构造函数就是为初始化对象而设计的，这个新创建的对象会被用作函数的调用上下文，因此在构造函数中可以通过<code>this</code>关键字引用这个新对象。<strong>注意，即使构造函数调用看起来像方法调用，这个新对象也仍然会被用作调用上下文。换句话说，在表达式<code>new o.m()</code>中，<code>o</code>不会用作调用上下文。</strong></p>","autoDesc":true}');export{d as comp,m as data};
