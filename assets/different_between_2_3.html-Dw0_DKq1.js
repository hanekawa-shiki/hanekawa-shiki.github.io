import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,b as n,o as r}from"./app-Djf3hfTT.js";const a={};function s(i,e){return r(),t("div",null,e[0]||(e[0]=[n('<h2 id="_1-性能改进" tabindex="-1"><a class="header-anchor" href="#_1-性能改进"><span>1. <strong>性能改进</strong></span></a></h2><ul><li><p><strong>响应式系统的优化</strong>：</p><ul><li><strong>Vue 2</strong>：基于 <code>Object.defineProperty</code> 实现响应式，无法实现对数组的变化，对于对象需要递归便利监听每个属性。</li><li><strong>Vue 3</strong>：采用了基于 Proxy 的全新响应式系统，Proxy可以直接监听数组的变化；proxy直接监听代理整个对象，而不是属性。</li></ul></li><li><p><strong>编译器优化</strong>：</p><ul><li><strong>Vue 3</strong>：引入了静态提升、缓存事件处理器、碎片化更新等多种编译优化技术，使得模板编译后的代码更加高效。 <ul><li>静态提升是指在编译阶段将不变的静态内容提取到渲染函数外部，从而避免每次渲染时都重新创建这些内容。这包括静态的 HTML 结构和属性。</li><li>Vue 2 中，每次组件重新渲染时，模板中绑定的事件处理器函数都会被重新创建。Vue 3 通过缓存事件处理器来优化这一过程。即使组件重新渲染，事件处理器函数也不会重新创建，而是直接从缓存中获取。这减少了内存使用和处理器开销。</li><li>碎片化更新（也叫 Patch Flag 优化）是 Vue 3 用来减少 DOM 更新的技术。通过在编译阶段给不同的节点打上特殊的标记 (Patch Flags)，Vue 3 在运行时可以只更新那些实际发生变化的部分，而不是进行整个树的对比和更新。</li></ul></li></ul></li></ul><h2 id="_2-组合式-api-composition-api" tabindex="-1"><a class="header-anchor" href="#_2-组合式-api-composition-api"><span>2. <strong>组合式 API (Composition API)</strong></span></a></h2><ul><li><strong>Vue 2</strong>：主要使用选项式 API (Options API)，通过 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 等选项来组织代码。这种方式在大型组件中可能导致代码分散且不易管理。</li><li><strong>Vue 3</strong>：引入了组合式 API，允许通过 <code>setup</code> 函数使用 <code>ref</code>、<code>reactive</code>、<code>computed</code>、<code>watch</code> 等 API，更灵活地组织和复用代码逻辑，尤其适用于复杂逻辑或逻辑复用的场景。</li></ul><h2 id="_3-片段-fragments" tabindex="-1"><a class="header-anchor" href="#_3-片段-fragments"><span>3. <strong>片段 (Fragments)</strong></span></a></h2><ul><li><strong>Vue 2</strong>：一个组件必须有一个根节点，不能直接返回多个根元素。</li><li><strong>Vue 3</strong>：支持片段，允许组件返回多个根节点，从而减少不必要的 DOM 元素层级。</li></ul><h2 id="_4-更好的-typescript-支持" tabindex="-1"><a class="header-anchor" href="#_4-更好的-typescript-支持"><span>4. <strong>更好的 TypeScript 支持</strong></span></a></h2><ul><li><strong>Vue 2</strong>：虽然支持 TypeScript，但并不是设计之初的重点，因此使用时可能会遇到类型推断不完整等问题。</li><li><strong>Vue 3</strong>：从底层开始就对 TypeScript 进行了更好的支持，Vue 3 的核心代码完全使用 TypeScript 编写，类型推断更完整，开发体验更好。</li></ul><h2 id="_5-vue-3-的树形摇树优化-tree-shaking" tabindex="-1"><a class="header-anchor" href="#_5-vue-3-的树形摇树优化-tree-shaking"><span>5. <strong>Vue 3 的树形摇树优化 (Tree Shaking)</strong></span></a></h2><ul><li><strong>Vue 2</strong>：Vue 2 的代码库在打包时不能很好地进行摇树优化，可能会打包一些未使用的代码。</li><li><strong>Vue 3</strong>：通过模块化的设计，使得未使用的部分代码在打包时可以被自动移除，减少打包后的体积。</li></ul><h2 id="_6-自定义渲染器" tabindex="-1"><a class="header-anchor" href="#_6-自定义渲染器"><span>6. <strong>自定义渲染器</strong></span></a></h2><ul><li><strong>Vue 2</strong>：虽然可以通过 render 函数自定义渲染逻辑，但框架的渲染机制是固定的。</li><li><strong>Vue 3</strong>：提供了更灵活的自定义渲染器 API，可以更自由地控制渲染过程，适用于非 DOM 平台或自定义渲染场景。</li></ul><h2 id="_7-事件处理器缓存" tabindex="-1"><a class="header-anchor" href="#_7-事件处理器缓存"><span>7. <strong>事件处理器缓存</strong></span></a></h2><ul><li><strong>Vue 2</strong>：在模板中每次渲染都需要重新绑定事件处理函数，这会带来一些性能开销。</li><li><strong>Vue 3</strong>：通过缓存事件处理器，减少了不必要的重新绑定，从而提升了渲染性能。</li></ul><h2 id="_8-响应式-api" tabindex="-1"><a class="header-anchor" href="#_8-响应式-api"><span>8. <strong>响应式 API</strong></span></a></h2><ul><li><strong>Vue 3</strong>：新增了 <code>ref</code>、<code>reactive</code>、<code>toRefs</code>、<code>readonly</code> 等响应式 API，使得响应式数据的定义和处理更加灵活方便。</li></ul><h2 id="_9-teleport-组件" tabindex="-1"><a class="header-anchor" href="#_9-teleport-组件"><span>9. <strong>Teleport 组件</strong></span></a></h2><ul><li><strong>Vue 3</strong>：引入了 Teleport 组件，允许你在不改变组件结构的情况下，将其渲染到 DOM 树中的其他位置。</li></ul><h2 id="_10-异步组件和-suspense" tabindex="-1"><a class="header-anchor" href="#_10-异步组件和-suspense"><span>10. <strong>异步组件和 Suspense</strong></span></a></h2><ul><li><strong>Vue 3</strong>：增强了异步组件的支持，并引入了 <code>Suspense</code> 组件，用于处理异步内容的加载过程，提供了更好的用户体验。</li></ul><h2 id="_11-自定义指令-api-的变化" tabindex="-1"><a class="header-anchor" href="#_11-自定义指令-api-的变化"><span>11. <strong>自定义指令 API 的变化</strong></span></a></h2><ul><li><strong>Vue 3</strong>：在指令的生命周期钩子中，移除了 <code>bind</code> 和 <code>componentUpdated</code> 钩子，新增了 <code>beforeMount</code>、<code>mounted</code>、<code>beforeUpdate</code>、<code>updated</code> 钩子。</li></ul><h2 id="_12-生命周期钩子的命名变化" tabindex="-1"><a class="header-anchor" href="#_12-生命周期钩子的命名变化"><span>12. <strong>生命周期钩子的命名变化</strong></span></a></h2><ul><li><strong>Vue 3</strong>：生命周期钩子的命名进行了调整，使其更具一致性和语义化： <ul><li><code>beforeCreate</code> -&gt; <code>setup()</code></li><li><code>created</code> -&gt; <code>setup()</code></li><li><code>beforeMount</code> -&gt; <code>onBeforeMount</code></li><li><code>mounted</code> -&gt; <code>onMounted</code></li><li><code>beforeUpdate</code> -&gt; <code>onBeforeUpdate</code></li><li><code>updated</code> -&gt; <code>onUpdated</code></li><li><code>beforeDestroy</code> -&gt; <code>onBeforeUnmount</code></li><li><code>destroyed</code> -&gt; <code>onUnmounted</code></li></ul></li></ul>',24)]))}const c=o(a,[["render",s]]),u=JSON.parse('{"path":"/framework_front/vue3/different_between_2_3.html","title":"vue2 和 vue3 设计上的区别","lang":"zh-CN","frontmatter":{"title":"vue2 和 vue3 设计上的区别","article":false,"description":"1. 性能改进 响应式系统的优化： Vue 2：基于 Object.defineProperty 实现响应式，无法实现对数组的变化，对于对象需要递归便利监听每个属性。 Vue 3：采用了基于 Proxy 的全新响应式系统，Proxy可以直接监听数组的变化；proxy直接监听代理整个对象，而不是属性。 编译器优化： Vue 3：引入了静态提升、缓存事件处...","head":[["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"vue2 和 vue3 设计上的区别\\",\\"description\\":\\"1. 性能改进 响应式系统的优化： Vue 2：基于 Object.defineProperty 实现响应式，无法实现对数组的变化，对于对象需要递归便利监听每个属性。 Vue 3：采用了基于 Proxy 的全新响应式系统，Proxy可以直接监听数组的变化；proxy直接监听代理整个对象，而不是属性。 编译器优化： Vue 3：引入了静态提升、缓存事件处...\\"}"],["meta",{"property":"og:url","content":"https://hanekawa.top/framework_front/vue3/different_between_2_3.html"}],["meta",{"property":"og:site_name","content":"hanekawa-shiki"}],["meta",{"property":"og:title","content":"vue2 和 vue3 设计上的区别"}],["meta",{"property":"og:description","content":"1. 性能改进 响应式系统的优化： Vue 2：基于 Object.defineProperty 实现响应式，无法实现对数组的变化，对于对象需要递归便利监听每个属性。 Vue 3：采用了基于 Proxy 的全新响应式系统，Proxy可以直接监听数组的变化；proxy直接监听代理整个对象，而不是属性。 编译器优化： Vue 3：引入了静态提升、缓存事件处..."}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-15T12:04:45.000Z"}],["meta",{"property":"article:modified_time","content":"2024-08-15T12:04:45.000Z"}]]},"git":{"createdTime":1723723485000,"updatedTime":1723723485000,"contributors":[{"name":"kamishima-kaede","username":"kamishima-kaede","email":"kamiacgxu@gmail.com","commits":1,"url":"https://github.com/kamishima-kaede"}]},"readingTime":{"minutes":3.7,"words":1110},"filePathRelative":"framework_front/vue3/different_between_2&3.md","excerpt":"<h2>1. <strong>性能改进</strong></h2>\\n<ul>\\n<li>\\n<p><strong>响应式系统的优化</strong>：</p>\\n<ul>\\n<li><strong>Vue 2</strong>：基于 <code>Object.defineProperty</code> 实现响应式，无法实现对数组的变化，对于对象需要递归便利监听每个属性。</li>\\n<li><strong>Vue 3</strong>：采用了基于 Proxy 的全新响应式系统，Proxy可以直接监听数组的变化；proxy直接监听代理整个对象，而不是属性。</li>\\n</ul>\\n</li>\\n<li>\\n<p><strong>编译器优化</strong>：</p>\\n<ul>\\n<li><strong>Vue 3</strong>：引入了静态提升、缓存事件处理器、碎片化更新等多种编译优化技术，使得模板编译后的代码更加高效。\\n<ul>\\n<li>静态提升是指在编译阶段将不变的静态内容提取到渲染函数外部，从而避免每次渲染时都重新创建这些内容。这包括静态的 HTML 结构和属性。</li>\\n<li>Vue 2 中，每次组件重新渲染时，模板中绑定的事件处理器函数都会被重新创建。Vue 3 通过缓存事件处理器来优化这一过程。即使组件重新渲染，事件处理器函数也不会重新创建，而是直接从缓存中获取。这减少了内存使用和处理器开销。</li>\\n<li>碎片化更新（也叫 Patch Flag 优化）是 Vue 3 用来减少 DOM 更新的技术。通过在编译阶段给不同的节点打上特殊的标记 (Patch Flags)，Vue 3 在运行时可以只更新那些实际发生变化的部分，而不是进行整个树的对比和更新。</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{c as comp,u as data};
